COMPILER ProyectoFinal

  string variableName;
  string functionName;

  private ProyectoPruebas.VarTable tab;

  int constCont = 0;

  internal ProyectoPruebas.VarTable Tab { get => Tab1; set => Tab1 = value; }
  internal ProyectoPruebas.VarTable Tab1 { get => tab; set => tab = value; }

CHARACTERS
  Letter = 'A'..'Z' + 'a'..'z'. 
  Digit = '0'..'9'.
  Zero = '0'.
  NonZeroDigit = Digit - Zero.
  CharInLine = ANY - '\r' - '\n'.
  AnyButDoubleQuote = CharInLine - '\"'.
  DoubleQuote = '\"'.

TOKENS
  Id = Letter { Letter | Digit }.
  Program = "program".
  Var = "Var".
  Int = "Int".
  Float = "Float".
  Print = "Print".
  Comma = ','.
  Colon = ':'.
  Semicolon = ';'.
  If = "If".
  Else = "Else".
  ElseIf = "ElseIf".
  EndIf = "EndIf".
  LeftParenthesis = '('.
  RightParenthesis = ')'.
  LeftCurlyBracket = '{'.
  RightCurlyBracket = '}'.
  CTE_I = Zero | (NonZeroDigit { Digit }).
  CTE_F = Digit '.' Digit { Digit }.
  CTE_S = DoubleQuote { AnyButDoubleQuote } DoubleQuote.
  Plus = '+'.
  Minus = '-'.
  Asterisk = '*'.
  Slash = '/'.
  Equal = '='.
  EqualThan = "==".
  GreaterThan = '>'.
  LesserThan = '<'.
  NotEqual = "<>".
  GreaterThanOrEqual = ">=".
  LessThanOrEqual = "<=".
  Function = "Function".
  Void = "Void".
  Return = "Return".
  EndFunction = "EndFunction".
  Bool = "Bool".
  String = "String".
  TurnLeft = "TurnLeft".
  TurnRight = "TurnRight".
  Shoot = "Shoot".
  Wait = "Wait".
  MoveForward = "MoveForward".
  Interact = "Interact".
  For = "For".
  EndFor = "EndFor".
  Loop = "Loop".
  EndLoop = "EndLoop".

IGNORE '\r' + '\n' + '\t' + '\f'

PRODUCTIONS
ProyectoFinal = PROGRAM.
PROGRAM = VARS {MODULE} STATUTE {STATUTE}.
VARS = {VAR}.

VAR                   
    = Var   (. string name; int type; .)
      TYPE  (. type = t.kind;.)
      Id    (. name =  t.val; 
               ProyectoPruebas.Variable var = new ProyectoPruebas.Variable(name, type);
               .)
    Equal 
    (NUMBER | CTE_S) (. var.setValue(t.val);
                        tab.addVariable(var);.)
    Semicolon. 
NUMBER = CTE_I 
        | CTE_F.
MODULE = Function       (. string functName; int type;.)
        (TYPE | Void)   (. type = t.kind;.)
        Id              (. functName = t.val; 
                           ProyectoPruebas.Function fun = new ProyectoPruebas.Function(functName, type);
                           tab.addFunction(fun);
                           .)
        PARAMS Colon STATUTE {STATUTE} [MODULE_RETURN] EndFunction.
MODULE_RETURN = Return EXPR.

PARAMS = LeftParenthesis [PARAMS_1] RightParenthesis.
PARAMS_1 = TYPE Id {Comma TYPE Id}.
TYPE = Float 
      | Int 
      | String 
      | Bool.

COMMAND = COMMAND_LIST Semicolon.

COMMAND_LIST = TurnLeft 
              | TurnRight 
              | Shoot 
              | Wait  
              | MoveForward 
              | Interact 
              | PRINT.

PRINT = Print LeftParenthesis (CTE_S | Id) RightParenthesis.

CYCLE = FOR 
        | LOOP.
FOR = For (. tab.codeGenerator.pushJumpStack(tab.codeGenerator.getLineCont() +1); .)
      LeftParenthesis EXPRESSION 
      RightParenthesis (. ProyectoPruebas.Variable result = tab.codeGenerator.popSymnbolStack();

                          if(result.getType() != ProyectoPruebas.OperationTypes.TYPE_BOOL){

                              SemErr("Type-mismatch: Expected a bool type operation");
                          }
                          else{

                            tab.codeGenerator.pushGoToF(result);
                          }
                      .)
      STATUTE {STATUTE} 
      EndFor  (. tab.codeGenerator.solveFor(); .)
      .

LOOP = Loop (CTE_I | Id) STATUTE {STATUTE} EndLoop.

CONDITION = If LeftParenthesis EXPRESSION 
            RightParenthesis  (. ProyectoPruebas.Variable result = tab.codeGenerator.popSymnbolStack();
                                  if(result.getType() != ProyectoPruebas.OperationTypes.TYPE_BOOL){

                                      SemErr("Type-mismatch: Expected a bool type operation");
                                  }
                                  else{

                                    tab.codeGenerator.pushGoToF(result);
                                  }
                               .)
            STATUTE 
            {STATUTE}  [CONDITION_ELSE] 
            EndIf           (. tab.codeGenerator.popJumpStack();.)
            .
CONDITION_ELSE = ELSE 
                | ELSEIF.
ELSE = Else   (. tab.codeGenerator.popJumpStack();
                         tab.codeGenerator.pushGoTo();
                      .)
 STATUTE {STATUTE}.
ELSEIF = ElseIf LeftParenthesis EXPRESSION RightParenthesis STATUTE {STATUTE} [CONDITION_ELSE].

STATUTE = COMMAND 
          | CONDITION 
          | CYCLE 
          | ASGMT_OR_FUNCT.
          
ASGMT_OR_FUNCT = 
                Id (. variableName = t.val; .)
                (FUNCTCALL | ASSIGNMENT) Semicolon.

FUNCTCALL  = 
            LeftParenthesis (. ProyectoPruebas.Function fun = tab.findFunction(variableName);
                                if(fun == null){
                                    SemErr("Function " + variableName + " not declared");
                                }
                                else{

                                    ProyectoPruebas.Variable functVar = new ProyectoPruebas.Variable("FUNCT"+fun.getName(), fun.getReturnType());

                                    tab.codeGenerator.pushSymbolStack(functVar);


                                }.)
            [FUNCT_PARAMS] RightParenthesis.
FUNCT_PARAMS = EXPR {Comma EXPR}.

ASSIGNMENT = 
            Equal (.   ProyectoPruebas.Variable var = tab.findVariable(variableName);
                      if(var == null){
                        SemErr("Variable " + variableName +  " not declared");
                      }
                      else{
                        tab.codeGenerator.pushOperatorStack(t.kind);
                        tab.codeGenerator.pushSymbolStack(var);
                      }

                      
                      .)
            (EXPR | CTE_S)
              (.if(!tab.codeGenerator.solveAssignment()){
                      SemErr("Type-mismatch at assignment");
                }.)
            .

EXPRESSION = EXPR [EXPRESSION_1].
EXPRESSION_1 = RELOPS (.tab.codeGenerator.pushOperatorStack(t.kind);.)
              EXPR
              (. tab.codeGenerator.solveRelOp();.)
              .

RELOPS = EqualThan
        | GreaterThan 
        | GreaterThanOrEqual 
        | LesserThan 
        | LessThanOrEqual 
        | NotEqual.



EXPR = TERM   (. //Console.WriteLine(t.kind + " " + t.line);
                .)
              {
              (Plus | Minus)  (.tab.codeGenerator.pushOperatorStack(t.kind);.)
               TERM
                 (. if(!tab.codeGenerator.solveSumAndMinus()){
                      SemErr("Type-mismatch");
                     }

                  .)
               }.

TERM = FACTOR 
      { 
      (Asterisk | Slash)  (.tab.codeGenerator.pushOperatorStack(t.kind);.)
       FACTOR
         (. if(!tab.codeGenerator.solveMultAndDiv()){
                SemErr("Type-mismatch");
            }

            .)
        }
       .

FACTOR = FACTOR_1 
        | FACTOR_2.
FACTOR_1 = LeftParenthesis (.tab.codeGenerator.pushOperatorStack(t.kind);.)
          EXPR
          RightParenthesis  (. tab.codeGenerator.popOperatorStack();.)
          .
FACTOR_2 = [SIGNS] FACTOR_VALUES.
FACTOR_VALUES = Id (. //Variable que guarda el Id que acaba de encontrar
                      variableName = t.val;

                      //Variable que dice si entró a una función o no
                      bool enterFunction = false;.)

                [ (. //Si se ejecuta esta parte es que se reconoció una función
                    enterFunction = true; .)
               
                FUNCTCALL  
                ]  (. //Si no entró a una función, quiere decir que se encontró una variable
                      if(!enterFunction){
                        ProyectoPruebas.Variable varId = tab.findVariable(variableName);
                        if(varId != null){
                           tab.codeGenerator.pushSymbolStack(varId);
                        }
                      }.)
                | NUMBER (. string constNumber = t.val;
                            int constType = t.kind;
                            
                            ProyectoPruebas.Variable constVar = new ProyectoPruebas.Variable(constNumber, constType);

                            tab.codeGenerator.pushSymbolStack(constVar);
                          .)
                .
SIGNS = Plus 
        | Minus.
	
END ProyectoFinal.